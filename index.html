<script>
  const JSON_PATH = 'content/index.json';
  const titre = document.getElementById('titre');
  const row   = document.getElementById('row');

  let works = [];     // données index.json
  let ready = false;  // JSON chargé
  let shown = false;  // nébuleuse déjà affichée ?

  function rand(min,max){ return Math.random() * (max - min) + min; }

  function shuffle(array){
    for(let i = array.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  // place les titres aléatoirement, tous à des hauteurs (y) distinctes,
  // ET loin de leur précédente position pour que le changement soit visible
  function scatter(){
    const entries = Array.from(row.children);
    if (!entries.length) return;

    const W = window.innerWidth;
    const H = window.innerHeight;
    const margin = 24;

    // zone interdite autour du titre central
    const tRect = titre.getBoundingClientRect();
    const pad = 32;
    const forbid = {
      left:   tRect.left   - pad,
      right:  tRect.right  + pad,
      top:    tRect.top    - pad,
      bottom: tRect.bottom + pad
    };

    // ordre aléatoire
    shuffle(entries);
    entries.forEach(e => row.appendChild(e));

    const usedY = [];
    const minYSpacing = 28;   // écart vertical minimum entre titres
    const minMoveDist = 40;   // distance minimale par rapport à l’ancienne position

    entries.forEach(el => {
      const w = el.offsetWidth || 80;
      const h = el.offsetHeight || 20;

      // ancienne position (si elle existe)
      const prevX = el.dataset.x ? parseFloat(el.dataset.x) : null;
      const prevY = el.dataset.y ? parseFloat(el.dataset.y) : null;

      let x, y, tries = 0;

      while (true) {
        x = rand(margin, W - w - margin);
        y = rand(margin, H - h - margin);

        const left = x;
        const right = x + w;
        const top = y;
        const bottom = y + h;

        // éviter la zone du titre
        const overlapTitle =
          !(right < forbid.left ||
            left  > forbid.right ||
            bottom < forbid.top ||
            top > forbid.bottom);

        if (overlapTitle && tries < 50) {
          tries++;
          continue;
        }

        // éviter de retomber sur la même "ligne" qu’un autre titre
        let tooCloseY = false;
        for (const yUsed of usedY) {
          if (Math.abs(y - yUsed) < minYSpacing) {
            tooCloseY = true;
            break;
          }
        }
        if (tooCloseY && tries < 80) {
          tries++;
          continue;
        }

        // s’éloigner clairement de l’ancienne position
        if (prevX !== null && prevY !== null) {
          const dist = Math.hypot(x - prevX, y - prevY);
          if (dist < minMoveDist && tries < 100) {
            tries++;
            continue;
          }
        }

        usedY.push(y);
        break;
      }

      // mémoriser la nouvelle position
      el.dataset.x = x;
      el.dataset.y = y;

      el.style.transform = `translate(${x}px, ${y}px)`;
    });
  }

  function buildEntries(){
    row.innerHTML = '';
    works.forEach(it => {
      const a = document.createElement('a');
      a.className = 'entry';
      a.textContent = it.title;
      a.href = it.path;
      a.target = '_self';
      row.appendChild(a);
    });
  }

  // Clic sur le titre : fait apparaître / remélange la nébuleuse
  titre.addEventListener('click', () => {
    if (!ready) return;
    if (!shown){
      buildEntries();
      row.classList.add('shown');
      shown = true;
    }
    requestAnimationFrame(scatter);
  });

  // Au resize, on recalcule la dispersion si elle est visible
  window.addEventListener('resize', () => {
    if (shown) scatter();
  });

  // Chargement des données depuis content/index.json
  fetch(JSON_PATH + '?_=' + Date.now())
    .then(r => r.json())
    .then(list => {
      works = list;
      ready = true;
    })
    .catch(() => {
      works = [{ title: 'error loading index.json', path: '#' }];
      ready  = true;
    });
</script>
